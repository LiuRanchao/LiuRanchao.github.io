---
layout: post
title: android面试题
tags:
- android
- 面试
categories: Android
description: android面试题
---


### Java基础

#### 列举java的集合和继承关系

~~~ java
Collection
    |- List
    |   |- LinkedList
    |   |- ArrarList
    |   |- Vector
    |   |- Stack
    |- Set
    
Map
 |- HashTable
 |- HashMap
 |- WeakHashMap
~~~    
  
#### 哪些情况下的对象会被垃圾回收机制处理掉

Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。

#### 进程和线程的区别

内存：<br>
线程：共享内存 <br>
进程：独立内存

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。

#### java中==和equals和hashCode的区别

如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。<br>
如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果

覆盖equals时总要覆盖hashCode <br>
  一个很常见的错误根源在于没有覆盖hashCode方法。在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。 
  
#### 常见的排序算法时间复杂度

排序法  | 平均时间 | 最差情形 | 稳定度 | 额外空间 | 备注
-------|---------|--------| -------|---------|------
冒泡    | O(n^2) | O(n^2)  | 稳定    | O(1)   | n小时较好
交换    | O(n^2) | O(n^2)  | 不稳定  | O(1)   | n小时较好
选择    | O(n^2) | O(n^2)  | 不稳定  | O(1)   | n小时较好
插入    | O(n^2) | O(n^2)  | 稳定    | O(1)   | 大部分已排序时较好
基数    | O(logR^b) | O(n^2)  | 稳定    | O(n)   | B是真数(0-9),R是基数(个十百)
Shell   | O(nlogn) | O(n^s) 1<s<2  | 不稳定    | O(1)   | s是所选分组
快速    | O(nlogn) | O(n^2)  | 不稳定    | O(nlogn)   | n大时较好
归并    | O(nlogn) | O(nlogn)  | 稳定    | O(1)   | n大时较好
堆    | O(nlogn) | O(nlogn)  | 不稳定    | O(1)   | n大时较好

#### HashMap的实现原理

1. HashMap概述：    HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
2. HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。

#### int-char-long各占多少字节数

名称    | 位数   | 字节数 
-------|-------|--------
byte   | 8     | 1
short  | 16    | 2
int    | 32    | 4
long   | 64    | 8
float  | 32    | 4
double | 64    | 8
char   | 16    | 2

#### java多态

面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。

多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）

实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实 际类型，根据其实际的类型调用其相应的方法。

多态的作用：消除类型之间的耦合关系。

现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 下面是多态存在的三个必要条件，要求大家做梦时都能背出来！

多态存在的三个必要条件 一、要有继承； 二、要有重写； 三、父类引用指向子类对象。

 多态的好处：

1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。

2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。

3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。

4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。

5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。

Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。

#### 抽象类接口区别

1. 默认的方法实现 抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现

2. 实现 :子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。
子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现

3. 构造器:
抽象类可以有构造器 接口不能有构造器

4. 访问修饰符:
抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public。你不可以使用其它修饰符。

5. 多继承:
抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。

### Android相关

